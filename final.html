<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çš‡å®¶èµŒåœº - ç¨³å®šç‰ˆ</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- 1. åŸºç¡€è®¾ç½® --- */
        * { box-sizing: border-box; }
        body { 
            margin: 0; padding: 0; background: #000; overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            height: 100vh; width: 100vw; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* æ¡Œé¢èƒŒæ™¯ */
        #table {
            position: relative; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1b5e20 0%, #05220a 100%);
            box-shadow: inset 0 0 100px #000;
            display: flex; justify-content: center; align-items: center;
        }
        #table:: after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('https://www.transparenttextures.com/patterns/felt.png');
            opacity: 0.4; pointer-events: none;
        }

        /* --- 2. æ ¸å¿ƒç»„ä»¶ --- */
        . card-wrapper {
            width: 46px; height: 68px; position: absolute;
            transform-style: preserve-3d; 
            transition: transform 0.6s ease-out, top 0.5s ease-out, left 0.5s ease-out;
            box-shadow: 1px 1px 5px rgba(0,0,0,0.5); 
            border-radius: 4px; z-index: 20;
            will-change: transform, top, left;
        }
        . card-face {
            position: absolute; width: 100%; height: 100%; 
            backface-visibility:  hidden;
            border-radius: 4px; display: flex; justify-content: center; align-items: center;
            font-size: 22px; font-weight: bold; background: #fff; border: 1px solid #ccc;
        }
        .card-back {
            background: #b71c1c; 
            background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.1) 0, rgba(255,255,255,0.1) 2px, transparent 2px, transparent 4px);
            border:  2px solid #eee; transform: rotateY(180deg);
        }
        .card-front { transform: rotateY(0deg); color: #000; }
        .card-front.red { color: #d32f2f; }

        #deck-pile {
            position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);
            width: 46px; height: 68px; background: #b71c1c; border-radius: 4px;
            box-shadow: -2px 2px 0 #8b0000, -4px 4px 0 #8b0000, 0 5px 15px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }

        #pot-area {
            position: absolute; top: 25%; left: 50%; transform:  translate(-50%, -50%);
            background: rgba(0,0,0,0.3); padding: 5px 20px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); text-align: center;
            min-width: 100px;
        }
        . pot-val { color: #f1c40f; font-size:  24px; font-weight: 800; text-shadow: 0 2px 4px black; }
        .pot-label { color: #aaa; font-size: 10px; letter-spacing: 1px; text-transform: uppercase; }

        /* --- 3. ç©å®¶åº§ä½ --- */
        .seat { 
            position: absolute; width:  100px; height: 120px; z-index: 10; 
            display: flex; flex-direction: column; align-items: center; 
            transition: opacity 0.3s; 
        }
        .seat-bottom { bottom: 120px; left: 50%; transform: translateX(-50%); } 
        .seat-top { top: 50px; left: 50%; transform:  translateX(-50%); }    
        .seat-left { top: 50%; left: 10px; transform: translateY(-50%); }
        .seat-right { top: 50%; right: 10px; transform: translateY(-50%); }

        . avatar {
            width: 50px; height: 50px; background: #333; border-radius: 50%; 
            border: 3px solid #555; display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: #fff; position: relative; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .avatar.active { 
            border-color: #f1c40f; 
            box-shadow: 0 0 15px #f1c40f; 
            animation: pulse-border 1. 5s infinite; 
        }
        
        . player-info { 
            text-align: center; margin-top: 5px; color: white; 
            text-shadow: 0 1px 3px black; width: 120px; 
        }
        .chips-tag { 
            color: #f1c40f; font-weight: bold; font-size: 14px; 
            background: rgba(0,0,0,0.6); padding: 2px 8px; 
            border-radius: 10px; display: inline-block;
        }
        
        .status-badge { 
            position: absolute; top: -10px; right: -10px;
            font-size: 10px; padding: 2px 6px; border-radius: 4px; 
            font-weight: bold; color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 15;
        }
        . badge-blind { background: #546e7a; border: 1px solid #78909c; }
        .badge-seen { background: #f39c12; border: 1px solid #f1c40f; color: black; }
        .badge-fold { background: #c0392b; opacity: 0.8; }
        .badge-dealer { background: #9b59b6; border: 1px solid #8e44ad; }

        . hand-zone { 
            position: relative; width: 80px; height: 50px; 
            margin-top: 5px; pointer-events: none;
        }

        /* --- 4. åº•éƒ¨æ“ä½œé¢æ¿ --- */
        #dashboard {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        #game-tip { 
            font-size: 12px; color: #aaa; margin-bottom: 8px; 
            width: 100%; text-align: center; height: 16px;
            transition: color 0.3s;
        }
        #game-tip. your-turn { 
            color: #2ecc71; font-weight:  bold; 
            animation: pulse 1s infinite; 
        }

        . control-bar {
            display: flex; align-items: center; justify-content: center; gap: 8px;
            width: 100%; padding: 0 10px; box-sizing: border-box;
        }

        .btn-func {
            height: 44px; padding: 0 12px; border-radius: 6px; border: none; 
            font-weight: bold; font-size: 13px;
            color: white; cursor: pointer; 
            transition: transform 0.1s, opacity 0.3s; 
            position: relative;
            display: flex; flex-direction: column; justify-content: center; 
            align-items: center; line-height: 1.1;
            min-width: 50px;
            touch-action: manipulation;
        }
        .btn-func:active { transform: scale(0.95); }
        .btn-func: disabled { 
            background: #333 !important; color: #666; 
            opacity: 0.5; cursor: not-allowed;
        }
        
        .btn-fold { background: #c0392b; box-shadow: 0 3px 0 #922b21; }
        .btn-look { background: #f39c12; color: #222; box-shadow: 0 3px 0 #d68910; }
        .btn-comp { background: #8e44ad; box-shadow: 0 3px 0 #6c3483; }

        .divider { 
            width: 1px; height: 30px; 
            background: rgba(255,255,255,0.2); 
            margin: 0 5px; 
        }

        .chip-btn {
            width: 44px; height: 44px; border-radius: 50%;
            border: 3px dashed rgba(255,255,255,0.5);
            display: flex; justify-content: center; align-items: center;
            font-size: 12px; font-weight: 900; color: white; cursor: pointer;
            position: relative; box-shadow: 0 3px 5px rgba(0,0,0,0.5);
            transition: transform 0.1s, opacity 0.3s;
            touch-action: manipulation;
        }
        .chip-btn:active { transform: scale(0.9); }
        .chip-btn. disabled { 
            opacity: 0.3; pointer-events: none; 
            cursor: not-allowed;
        }
        
        .c-5 { background: #c0392b; border-color: #e74c3c; } 
        .c-10 { background: #2980b9; border-color: #3498db; } 
        . c-20 { background: #27ae60; border-color: #2ecc71; } 
        .c-50 { background: #8e44ad; border-color:  #9b59b6; } 
        .c-100 { background: #f39c12; border-color: #f1c40f; color: black; }

        .cost-tag { 
            position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%);
            font-size: 9px; background: rgba(0,0,0,0.8); padding: 1px 4px; 
            border-radius: 4px; white-space: nowrap;
        }

        /* è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #conn-status {
            position: fixed; top: 10px; right: 10px; z-index: 9999;
            padding: 5px 10px; border-radius: 15px; font-size: 11px;
            font-weight:  bold; display: flex; align-items: center; gap: 5px;
        }
        . status-connected { background: #27ae60; color: white; }
        .status-connecting { background: #f39c12; color: black; }
        .status-disconnected { background: #c0392b; color: white; }

        /* --- 5. å¼¹çª—ä¸åŠ¨ç”» --- */
        #anim-layer { 
            position: absolute; top: 0; left:  0; 
            width: 100%; height: 100%; 
            pointer-events: none; z-index: 50; 
        }
        
        #lobby-modal {
            position: fixed; top: 0; left:  0; width: 100%; height: 100%;
            background: #111; z-index: 5000;
            display: flex; justify-content: center; align-items: center; 
            flex-direction: column; color: #fff;
        }
        input { 
            padding: 15px; font-size: 18px; border-radius: 8px; border: none; 
            text-align: center; margin:  15px; background: #333; color: white; 
            width: 70%; max-width: 400px;
        }
        
        .big-btn { 
            padding:  15px 40px; font-size: 18px; border-radius: 50px; 
            border: none; font-weight: bold; cursor: pointer; margin: 10px; 
            width: 80%; max-width: 300px; transition: 0.2s;
            touch-action: manipulation;
        }
        .big-btn:active { transform: scale(0.98); }

        #toast {
            position: fixed; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: #f1c40f; padding: 12px 30px;
            border:  1px solid #f1c40f; border-radius: 30px; display: none; 
            z-index: 6000; font-weight: bold; text-align: center;
            max-width: 80%;
        }

        @keyframes pulse-border { 
            0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7); } 
            70% { box-shadow: 0 0 0 10px rgba(241, 196, 15, 0); } 
            100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); } 
        }
        @keyframes pulse { 
            0% { opacity: 1; } 
            50% { opacity: 0.5; } 
            100% { opacity: 1; } 
        }
    </style>
</head>
<body>

<!-- è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ -->
<div id="conn-status" class="status-disconnected">
    <span id="conn-dot">â—</span>
    <span id="conn-text">æœªè¿æ¥</span>
</div>

<div id="lobby-modal">
    <h1 style="color:#f1c40f; margin-bottom: 0;">ğŸ›ï¸ çš‡å®¶èµŒåœº</h1>
    <p style="color:#666; font-size: 12px; margin-bottom: 40px;">v6.0 ç¨³å®šç‰ˆ</p>
    
    <div id="lobby-main" style="width: 100%; display: flex; flex-direction: column; align-items: center;">
        <button class="big-btn" style="background:#2980b9; color:  white;" onclick="initHost()">æˆ‘æ˜¯æˆ¿ä¸» (åˆ›å»º)</button>
        <div style="margin:  10px; color:#444">æˆ–è€…</div>
        <input type="text" id="join-id" placeholder="ç²˜è´´æˆ¿ä¸»ID">
        <button class="big-btn" style="background:#27ae60; color: white;" onclick="initGuest()">åŠ å…¥æˆ¿é—´</button>
    </div>

    <div id="lobby-wait" style="display: none; text-align: center; width: 100%; flex-direction: column; align-items: center;">
        <p style="color:#aaa">æˆ¿é—´ID (ç‚¹å‡»å¤åˆ¶):</p>
        <input type="text" id="my-id-disp" readonly onclick="copyId()" style="background:#fff; color:#000; font-weight: bold; cursor: pointer;">
        <div id="player-status" style="margin:  20px; color:  #ccc;">ç­‰å¾…ç©å®¶åŠ å…¥...</div>
        <button id="btn-start" class="big-btn" style="background:#f39c12; color: black; opacity: 0.5; pointer-events: none;" onclick="startGame()">
            ç­‰å¾…åŠ å…¥...  
        </button>
    </div>
</div>

<div id="table">
    <div id="deck-pile"></div>
    <div id="pot-area">
        <div class="pot-val" id="pot-val">0</div>
        <div class="pot-label">Total Pot</div>
    </div>
    <div id="seats-container"></div>
    <div id="anim-layer"></div>

    <div id="dashboard">
        <div id="game-tip">ç­‰å¾…å¼€å§‹...</div>
        
        <div class="control-bar">
            <button id="btn-fold" class="btn-func btn-fold" disabled onclick="userAct('fold')">å¼ƒç‰Œ<br><span style="font-size: 9px; font-weight: normal;">Fold</span></button>
            <button id="btn-look" class="btn-func btn-look" disabled onclick="userAct('look')">çœ‹ç‰Œ<br><span style="font-size: 9px; font-weight:normal;">Look</span></button>
            <button id="btn-comp" class="btn-func btn-comp" disabled onclick="userAct('comp')">æ¯”ç‰Œ<br><span style="font-size:9px; font-weight:normal;" id="comp-price">100</span></button>
            
            <div class="divider"></div>
            
            <div class="chip-btn c-5 disabled" id="chip-5" onclick="userBet(5)">5<div class="cost-tag" id="tag-5">5</div></div>
            <div class="chip-btn c-10 disabled" id="chip-10" onclick="userBet(10)">10<div class="cost-tag" id="tag-10">10</div></div>
            <div class="chip-btn c-20 disabled" id="chip-20" onclick="userBet(20)">20<div class="cost-tag" id="tag-20">20</div></div>
            <div class="chip-btn c-50 disabled" id="chip-50" onclick="userBet(50)">50<div class="cost-tag" id="tag-50">50</div></div>
            <div class="chip-btn c-100 disabled" id="chip-100" onclick="userBet(100)">1h<div class="cost-tag" id="tag-100">100</div></div>
        </div>
    </div>
</div>

<div id="toast">æç¤ºä¿¡æ¯</div>

<script>
    // ==================== é…ç½®ä¸å¸¸é‡ ====================
    const PEER_CONF = { 
        config: { 
            iceServers: [ 
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls:  'stun:stun2.l.google.com:19302' },
                { urls:  'stun:stun. qq.com:3478' },
                { urls: 'stun:stun.miwifi.com:3478' }
            ],
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 10
        },
        debug: 1
    };
    
    const $ = id => document.getElementById(id);
    const toast = m => { 
        $('toast').innerText = m; 
        $('toast').style.display = 'block'; 
        setTimeout(() => $('toast').style.display = 'none', 2500); 
    };
    const sleep = ms => new Promise(r => setTimeout(r, ms));
    const INIT_CHIPS = 2000;
    const HEARTBEAT_INTERVAL = 3000;  // å¿ƒè·³é—´éš”
    const CONNECTION_TIMEOUT = 15000; // è¿æ¥è¶…æ—¶

    // ==================== å…¨å±€çŠ¶æ€ ====================
    let peer, conn, conns = []; 
    let myPid = -1, isHost = false, playerCount = 1;
    let heartbeatTimer = null;
    let lastHeartbeat = {};
    
    let state = { 
        phase: 'lobby', 
        pot: 0, 
        turn: 0, 
        dealer: 0, 
        players: [],
        roundActive: false,
        timestamp: Date.now()  // çŠ¶æ€æ—¶é—´æˆ³
    };
    
    let actionQueue = [];  // åŠ¨ä½œé˜Ÿåˆ—
    let isProcessing = false;

    // ==================== è¿æ¥çŠ¶æ€ç®¡ç† ====================
    function updateConnStatus(status, text) {
        const statusEl = $('conn-status');
        const dotEl = $('conn-dot');
        const textEl = $('conn-text');
        
        statusEl. className = '';
        if (status === 'connected') {
            statusEl.classList.add('status-connected');
            textEl.innerText = 'å·²è¿æ¥';
        } else if (status === 'connecting') {
            statusEl. classList.add('status-connecting');
            textEl.innerText = text || 'è¿æ¥ä¸­...';
        } else {
            statusEl.classList.add('status-disconnected');
            textEl.innerText = text || 'æœªè¿æ¥';
        }
    }

    // ==================== å¿ƒè·³æœºåˆ¶ ====================
    function startHeartbeat() {
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        
        heartbeatTimer = setInterval(() => {
            const now = Date.now();
            
            if (isHost) {
                // æˆ¿ä¸»å‘é€å¿ƒè·³
                broadcast({ t: 'HEARTBEAT', timestamp: now }, true);
                
                // æ£€æŸ¥å®¢æˆ·ç«¯å¿ƒè·³
                conns.forEach((c, idx) => {
                    if (c.open) {
                        const lastTime = lastHeartbeat[idx + 1] || now;
                        if (now - lastTime > CONNECTION_TIMEOUT) {
                            console.warn(`ç©å®¶ ${idx + 1} å¿ƒè·³è¶…æ—¶`);
                            toast(`ç©å®¶ ${idx + 1} è¿æ¥ä¸ç¨³å®š`);
                        }
                    }
                });
            } else {
                // å®¢æˆ·ç«¯å‘é€å¿ƒè·³å“åº”
                if (conn && conn.open) {
                    conn.send({ t: 'HEARTBEAT_ACK', timestamp: now });
                }
            }
        }, HEARTBEAT_INTERVAL);
    }

    // ==================== å¯é ä¼ è¾“ ====================
    function sendReliable(target, msg, retries = 3) {
        return new Promise((resolve, reject) => {
            let attempts = 0;
            
            const trySend = () => {
                attempts++;
                
                try {
                    if (Array.isArray(target)) {
                        // å¹¿æ’­
                        target.forEach(c => {
                            if (c && c.open) {
                                c.send(msg);
                            }
                        });
                        resolve();
                    } else {
                        // å•ä¸ªè¿æ¥
                        if (target && target.open) {
                            target.send(msg);
                            resolve();
                        } else {
                            throw new Error('Connection not open');
                        }
                    }
                } catch (err) {
                    console.error(`å‘é€å¤±è´¥ (å°è¯• ${attempts}/${retries}):`, err);
                    
                    if (attempts < retries) {
                        setTimeout(trySend, 500 * attempts);
                    } else {
                        reject(err);
                    }
                }
            };
            
            trySend();
        });
    }

    function broadcast(msg, skipReliable = false) {
        if (skipReliable) {
            conns.forEach(c => {
                if (c && c.open) {
                    try { c.send(msg); } catch (e) { console.error('å¹¿æ’­å¤±è´¥:', e); }
                }
            });
        } else {
            sendReliable(conns, msg).catch(err => {
                console. error('å¯é å¹¿æ’­å¤±è´¥:', err);
                toast('ç½‘ç»œä¸ç¨³å®šï¼Œæ­£åœ¨é‡è¯•...');
            });
        }
    }

    // ==================== æˆ¿ä¸»åˆå§‹åŒ– ====================
    function initHost() {
        isHost = true; 
        myPid = 0;
        
        $('lobby-main').style.display = 'none'; 
        $('lobby-wait').style.display = 'flex';
        updateConnStatus('connecting', 'åˆ›å»ºæˆ¿é—´ä¸­...');
        
        peer = new Peer(null, PEER_CONF);
        
        peer.on('open', id => {
            $('my-id-disp').value = id;
            console.log('âœ… æˆ¿ä¸»ID:', id);
            updateConnStatus('connected', `æˆ¿ä¸» (${playerCount}äºº)`);
            toast('æˆ¿é—´åˆ›å»ºæˆåŠŸï¼');
            startHeartbeat();
        });
        
        peer.on('connection', c => {
            console.log('ğŸ”— æ–°ç©å®¶æ­£åœ¨è¿æ¥.. .');
            
            c.on('open', () => {
                const newPid = conns.length + 1;
                conns. push(c);
                lastHeartbeat[newPid] = Date.now();
                
                console.log(`âœ… ç©å®¶ ${newPid} å·²è¿æ¥`);
                
                // ç«‹å³å‘é€æ¬¢è¿æ¶ˆæ¯
                sendReliable(c, { 
                    t: 'WELCOME', 
                    pid:  newPid,
                    playerCount: playerCount + 1,
                    timestamp: Date.now()
                }).then(() => {
                    playerCount++;
                    updateLobbyStatus();
                    updateConnStatus('connected', `æˆ¿ä¸» (${playerCount}äºº)`);
                    toast(`ç©å®¶ ${newPid} åŠ å…¥æˆåŠŸï¼`);
                }).catch(err => {
                    console.error('å‘é€æ¬¢è¿æ¶ˆæ¯å¤±è´¥:', err);
                });
            });
            
            c.on('data', d => {
                if (d.t === 'HEARTBEAT_ACK') {
                    const pid = conns.indexOf(c) + 1;
                    lastHeartbeat[pid] = Date.now();
                } else {
                    handleDataHost(d, conns. indexOf(c) + 1);
                }
            });
            
            c.on('close', () => {
                const pid = conns.indexOf(c) + 1;
                console.warn(`âŒ ç©å®¶ ${pid} æ–­å¼€è¿æ¥`);
                toast(`ç©å®¶ ${pid} å·²ç¦»å¼€`);
                updateConnStatus('disconnected', 'æœ‰ç©å®¶ç¦»å¼€');
                
                setTimeout(() => {
                    alert('æ¸¸æˆä¸­æ–­ï¼Œ3ç§’ååˆ·æ–°');
                    setTimeout(() => location.reload(), 3000);
                }, 1000);
            });
            
            c.on('error', err => {
                console.error('âŒ è¿æ¥é”™è¯¯:', err);
                toast('ç©å®¶è¿æ¥å‡ºé”™');
            });
        });
        
        peer.on('disconnected', () => {
            console. warn('âš ï¸ Peeræ–­å¼€ï¼Œå°è¯•é‡è¿...');
            updateConnStatus('connecting', 'é‡è¿ä¸­...');
            
            setTimeout(() => {
                if (! peer.destroyed) {
                    peer.reconnect();
                }
            }, 1000);
        });
        
        peer.on('error', err => {
            console.error('âŒ Peeré”™è¯¯:', err);
            updateConnStatus('disconnected', 'åˆ›å»ºå¤±è´¥');
            
            if (err.type === 'unavailable-id') {
                toast('IDè¢«å ç”¨ï¼Œåˆ·æ–°é‡è¯•');
                setTimeout(() => location.reload(), 2000);
            } else {
                toast('ç½‘ç»œé”™è¯¯:  ' + err.type);
            }
        });
    }

    // ==================== å®¢æˆ·ç«¯åˆå§‹åŒ– ====================
    function initGuest() {
        const dest = $('join-id').value. trim();
        if (! dest) return toast("è¯·è¾“å…¥æˆ¿ä¸»ID");
        
        $('lobby-main').innerHTML = "<h2 style='color:#f39c12;'>è¿æ¥ä¸­ï¼Œè¯·ç¨å€™...</h2>";
        updateConnStatus('connecting', 'è¿æ¥æˆ¿ä¸»...');
        
        peer = new Peer(null, PEER_CONF);
        
        let connectionTimeout = setTimeout(() => {
            if (!conn || !conn.open) {
                console.error('âŒ è¿æ¥è¶…æ—¶');
                updateConnStatus('disconnected', 'è¿æ¥è¶…æ—¶');
                toast('è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥IDåé‡è¯•');
                setTimeout(() => location.reload(), 3000);
            }
        }, CONNECTION_TIMEOUT);
        
        peer.on('open', myId => {
            console.log('âœ… æœ¬åœ°Peerå°±ç»ª:', myId);
            console.log('ğŸ”— æ­£åœ¨è¿æ¥æˆ¿ä¸»:', dest);
            
            conn = peer.connect(dest, {
                reliable: true,
                serialization: 'json'
            });
            
            conn.on('open', () => {
                clearTimeout(connectionTimeout);
                console.log('âœ… ä¸æˆ¿ä¸»è¿æ¥æˆåŠŸï¼');
                updateConnStatus('connected', 'å·²è¿æ¥');
                toast('è¿æ¥æˆåŠŸï¼Œç­‰å¾…å¼€å§‹.. .');
                startHeartbeat();
            });
            
            conn.on('data', handleDataGuest);
            
            conn.on('close', () => {
                console.error('âŒ ä¸æˆ¿ä¸»æ–­å¼€è¿æ¥');
                updateConnStatus('disconnected', 'è¿æ¥æ–­å¼€');
                clearInterval(heartbeatTimer);
                alert("ä¸æˆ¿ä¸»æ–­å¼€è¿æ¥");
                location.reload();
            });
            
            conn.on('error', err => {
                console.error('âŒ è¿æ¥é”™è¯¯:', err);
                updateConnStatus('disconnected', 'è¿æ¥å¤±è´¥');
                toast('è¿æ¥å¤±è´¥:  ' + err.type);
            });
        });
        
        peer.on('error', err => {
            clearTimeout(connectionTimeout);
            console.error('âŒ Peeré”™è¯¯:', err);
            updateConnStatus('disconnected', 'è¿æ¥å¤±è´¥');
            toast('æ— æ³•è¿æ¥:  ' + err.type);
            setTimeout(() => location.reload(), 3000);
        });
    }

    function updateLobbyStatus() {
        $('player-status').innerText = `å½“å‰äººæ•°: ${playerCount} (å«æˆ¿ä¸»)`;
        
        if (playerCount >= 2) {
            const btn = $('btn-start');
            btn.innerHTML = `ğŸš€ å¼€å§‹æ¸¸æˆ (${playerCount}äºº)`;
            btn.style.opacity = 1;
            btn.style.pointerEvents = 'auto';
            btn.style.background = '#27ae60';
        }
    }

    // ==================== æ•°æ®å¤„ç† ====================
    function handleDataGuest(d) {
        console.log('ğŸ“¨ æ”¶åˆ°:', d. t);
        
        switch (d.t) {
            case 'WELCOME':
                myPid = d.pid;
                playerCount = d.playerCount;
                $('lobby-main').innerHTML = `
                    <h2 style='color:#2ecc71; margin-top:50px;'>
                        âœ… è¿æ¥æˆåŠŸï¼<br>
                        <span style='font-size:16px; color:#aaa;'>ä½ æ˜¯ç©å®¶ ${myPid + 1}</span><br>
                        <span style='font-size:14px; color:#666;'>ç­‰å¾…æˆ¿ä¸»å¼€å§‹... </span>
                    </h2>
                `;
                break;
                
            case 'SYNC':
                if (d.state. timestamp > state.timestamp) {
                    state = d. state;
                    
                    if (state.phase === 'game' && $('lobby-modal').style.display !== 'none') {
                        $('lobby-modal').style.display = 'none';
                        renderSeats();
                    }
                    
                    renderUI();
                }
                break;
                
            case 'HEARTBEAT':
                // æˆ¿ä¸»å¿ƒè·³ï¼Œå‘é€å“åº”
                if (conn && conn.open) {
                    conn.send({ t: 'HEARTBEAT_ACK', timestamp: Date.now() });
                }
                break;
                
            case 'ANIM_DEAL':
                playDealAnim(d.toPid, d.cardIdx);
                break;
                
            case 'ANIM_CHIP':
                playChipAnim(d.pid, d.val);
                break;
                
            case 'TOAST':
                toast(d.msg);
                break;
        }
    }

    function handleDataHost(d, fromPid) {
        console.log(`ğŸ“¨ ç©å®¶ ${fromPid}:  ${d.t}`);
        
        if (d.t === 'ACT') {
            queueAction(fromPid, d.act, d.val);
        }
    }

    // ==================== åŠ¨ä½œé˜Ÿåˆ— ====================
    function queueAction(pid, act, val) {
        actionQueue.push({ pid, act, val, timestamp: Date.now() });
        processQueue();
    }

    async function processQueue() {
        if (isProcessing || actionQueue.length === 0) return;
        if (! state.roundActive && actionQueue[0].act !== 'look') {
            actionQueue.shift();  // ä¸¢å¼ƒéæ³•æ“ä½œ
            return;
        }
        
        isProcessing = true;
        const action = actionQueue. shift();
        
        try {
            await processAction(action. pid, action.act, action. val);
        } catch (err) {
            console. error('å¤„ç†åŠ¨ä½œå‡ºé”™:', err);
            toast('æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•');
        }
        
        isProcessing = false;
        
        // ç»§ç»­å¤„ç†é˜Ÿåˆ—
        if (actionQueue.length > 0) {
            setTimeout(processQueue, 100);
        }
    }

    // ==================== æ¸¸æˆé€»è¾‘ ====================
    async function startGame() {
        if (playerCount < 2) return toast('è‡³å°‘éœ€è¦2åç©å®¶');
        
        console.log('ğŸ® æ¸¸æˆå¼€å§‹ï¼');
        $('lobby-modal').style.display = 'none';
        
        state.players = [];
        for (let i = 0; i < playerCount; i++) {
            state.players[i] = { 
                chips:  INIT_CHIPS, 
                hand: [], 
                status: 'play', 
                seen: false, 
                folded: false 
            };
        }
        
        state.phase = 'game';
        state.turn = 0;
        state. dealer = -1;
        state.roundActive = false;
        state.timestamp = Date.now();

        await sendReliable(conns, { t: 'SYNC', state:  state });
        renderSeats();
        
        await sleep(500);
        startNewRound();
    }

    async function startNewRound() {
        if (isProcessing) {
            console.warn('âš ï¸ æ­£åœ¨å¤„ç†ä¸­ï¼Œè·³è¿‡æ–°å›åˆ');
            return;
        }
        
        isProcessing = true;
        console.log('ğŸ² å¼€å§‹æ–°å›åˆ');
        
        // æ´—ç‰Œ
        const suits = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
        const ranks = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
        let deck = [];
        suits.forEach(s => ranks.forEach(r => deck.push({ s, r })));
        
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }

        state.pot = 0;
        state.dealer = (state.dealer + 1) % playerCount;
        state.turn = (state.dealer + 1) % playerCount;
        state.roundActive = true;
        state. timestamp = Date.now();
        
        state.players. forEach(p => {
            if (p.chips > 0) {
                p.status = 'play'; 
                p.hand = [deck. pop(), deck.pop(), deck.pop()];
                p.seen = false; 
                p.folded = false;
            } else {
                p.status = 'lost';
            }
        });

        await sendReliable(conns, { t: 'SYNC', state: state });
        renderUI();
        
        // å‘ç‰ŒåŠ¨ç”»
        for (let c = 0; c < 3; c++) {
            for (let p = 0; p < playerCount; p++) {
                const pid = (state.dealer + 1 + p) % playerCount;
                if (state.players[pid].status === 'play') {
                    broadcast({ t: 'ANIM_DEAL', toPid:  pid, cardIdx: c }, true);
                    playDealAnim(pid, c);
                    await sleep(150);
                }
            }
        }
        
        await sleep(500);
        broadcast({ t: 'TOAST', msg: "å‘ç‰Œå®Œæ¯•ï¼Œè¯·ä¸‹æ³¨ï¼" }, true);
        toast("å‘ç‰Œå®Œæ¯•ï¼Œè¯·ä¸‹æ³¨ï¼");
        
        isProcessing = false;
    }

    async function processAction(pid, act, baseVal) {
        if (state.turn !== pid) {
            console.warn(`âš ï¸ ä¸æ˜¯ç©å®¶ ${pid} çš„å›åˆ`);
            return;
        }
        
        const p = state.players[pid];
        let actualCost = baseVal || 0;
        
        console.log(`âš¡ å¤„ç†ç©å®¶ ${pid} çš„ ${act}`);
        
        if (act === 'fold') {
            p.folded = true; 
            p.status = 'fold';
            broadcast({ t: 'TOAST', msg: `ç©å®¶ ${pid + 1} å¼ƒç‰Œ` }, true);
            
        } else if (act === 'look') {
            if (p.seen) return;
            p.seen = true;
            state.timestamp = Date.now();
            await sendReliable(conns, { t: 'SYNC', state: state });
            broadcast({ t: 'TOAST', msg: `ç©å®¶ ${pid + 1} çœ‹ç‰Œ` }, true);
            return;  // çœ‹ç‰Œä¸æ¢å›åˆ
            
        } else if (act === 'bet') {
            actualCost = p.seen ? baseVal * 2 : baseVal;
            if (p.chips >= actualCost) {
                p. chips -= actualCost; 
                state.pot += actualCost;
                broadcast({ t: 'ANIM_CHIP', pid, val: baseVal }, true); 
                playChipAnim(pid, baseVal);
                broadcast({ t: 'TOAST', msg: `ç©å®¶ ${pid + 1} ä¸‹æ³¨ ${actualCost}` }, true);
                await sleep(300);
            } else {
                broadcast({ t: 'TOAST', msg:  `ç©å®¶ ${pid + 1} ç­¹ç ä¸è¶³` }, true);
                return;
            }
            
        } else if (act === 'comp') {
            const base = 100;
            actualCost = p.seen ? base * 2 : base;
            if (p.chips >= actualCost) {
                p. chips -= actualCost; 
                state.pot += actualCost;
                endRound(pid);
                return;
            } else {
                broadcast({ t: 'TOAST', msg: `ç©å®¶ ${pid + 1} ç­¹ç ä¸è¶³` }, true);
                return;
            }
        }

        // åˆ‡æ¢å›åˆ
        let nextTurn = (state.turn + 1) % playerCount;
        let attempts = 0;
        
        while (attempts < playerCount) {
            if (state.players[nextTurn].status === 'play') {
                state.turn = nextTurn;
                break;
            }
            nextTurn = (nextTurn + 1) % playerCount;
            attempts++;
        }

        // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€äºº
        const activePlayers = state.players.filter(p => p.status === 'play');
        if (activePlayers.length === 1) {
            const winnerId = state.players. indexOf(activePlayers[0]);
            endRound(winnerId);
            return;
        }

        state.timestamp = Date.now();
        await sendReliable(conns, { t: 'SYNC', state: state });
        renderUI();
    }

    async function endRound(winnerPid) {
        state.roundActive = false;
        state.timestamp = Date.now();
        
        console.log(`ğŸ† ç©å®¶ ${winnerPid} è·èƒœ`);
        
        state.players[winnerPid].chips += state.pot;
        
        // æ‘Šç‰Œ
        state.players.forEach(p => {
            if (p.status === 'play' || p.status === 'fold') {
                p.seen = true;
            }
        });
        
        await sendReliable(conns, { t: 'SYNC', state: state });
        renderUI();
        
        broadcast({ t: 'TOAST', msg: `ğŸ† ç©å®¶ ${winnerPid + 1} èµ¢äº† ${state.pot} ç­¹ç ï¼` }, true);
        toast(`ğŸ† ç©å®¶ ${winnerPid + 1} èµ¢äº† ${state.pot} ç­¹ç ï¼`);
        
        await sleep(4000);
        
        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        let remainingPlayers = 0;
        state.players.forEach(p => {
            if (p.chips > 0) remainingPlayers++;
        });
        
        if (remainingPlayers === 1) {
            const finalWinner = state.players. findIndex(p => p.chips > 0);
            broadcast({ t: 'TOAST', msg: `ğŸ‰ æ¸¸æˆç»“æŸï¼ç©å®¶ ${finalWinner + 1} è·å¾—æœ€ç»ˆèƒœåˆ©ï¼` }, true);
            toast(`ğŸ‰ æ¸¸æˆç»“æŸï¼ç©å®¶ ${finalWinner + 1} è·å¾—æœ€ç»ˆèƒœåˆ©ï¼`);
            return;
        }
        
        if (isHost) {
            await sleep(1000);
            startNewRound();
        }
    }

    // ==================== ç”¨æˆ·æ“ä½œ ====================
    function userBet(baseVal) {
        if (state.turn !== myPid || ! state.roundActive) return;
        
        const p = state. players[myPid];
        const cost = p.seen ? baseVal * 2 : baseVal;
        
        if (p.chips < cost) {
            toast("ç­¹ç ä¸è¶³");
            return;
        }
        
        if (isHost) {
            queueAction(myPid, 'bet', baseVal);
        } else {
            sendReliable(conn, { t: 'ACT', act: 'bet', val: baseVal });
        }
    }

    function userAct(act) {
        if (state.turn !== myPid) return;
        if (! state.roundActive && act !== 'look') return;
        
        const p = state.players[myPid];
        
        if (act === 'look' && p.seen) {
            toast("å·²ç»çœ‹è¿‡ç‰Œäº†");
            return;
        }
        
        if (act === 'comp') {
            const base = 100;
            const cost = p.seen ? base * 2 : base;
            if (p.chips < cost) {
                toast("ç­¹ç ä¸è¶³");
                return;
            }
        }
        
        if (isHost) {
            queueAction(myPid, act);
        } else {
            sendReliable(conn, { t: 'ACT', act:  act });
        }
    }

    // ==================== UI æ¸²æŸ“ ====================
    function renderSeats() {
        const container = $('seats-container');
        container.innerHTML = '';
        
        for (let i = 0; i < playerCount; i++) {
            let posClass = '';
            const relIdx = (i - myPid + playerCount) % playerCount;
            
            if (playerCount === 2) {
                posClass = relIdx === 0 ? 'seat-bottom' : 'seat-top';
            } else {
                if (relIdx === 0) posClass = 'seat-bottom';
                else if (relIdx === 1) posClass = 'seat-right';
                else if (relIdx === 2) posClass = 'seat-top';
                else posClass = 'seat-left';
            }

            const div = document.createElement('div');
            div.className = `seat ${posClass}`;
            div.id = `seat-${i}`;
            div.innerHTML = `
                <div class="avatar" id="avt-${i}">P${i + 1}
                    <div class="status-badge badge-blind" id="badge-${i}">ğŸ™ˆ</div>
                </div>
                <div class="player-info">
                    <div class="chips-tag">ğŸ’° <span id="chips-${i}">${INIT_CHIPS}</span></div>
                </div>
                <div class="hand-zone" id="hand-${i}"></div>
            `;
            container.appendChild(div);
        }
    }

    function renderUI() {
        if (! state.players || state.players.length === 0) return;
        
        $('pot-val').innerText = state.pot;

        state.players.forEach((p, i) => {
            const chipsEl = $(`chips-${i}`);
            const badge = $(`badge-${i}`);
            const avt = $(`avt-${i}`);
            
            if (! chipsEl || !badge || !avt) return;
            
            chipsEl.innerText = p.chips;
            
            // çŠ¶æ€æ ‡è®°
            if (i === state.dealer) {
                badge.className = 'status-badge badge-dealer';
                badge.innerText = 'D';
            } else if (p.folded) {
                badge.className = 'status-badge badge-fold';
                badge.innerText = 'å¼ƒ';
            } else if (p. seen) {
                badge.className = 'status-badge badge-seen';
                badge.innerText = 'ğŸ‘€';
            } else {
                badge.className = 'status-badge badge-blind';
                badge.innerText = 'ğŸ™ˆ';
            }

            // å›åˆé«˜äº®
            if (i === state.turn && state.roundActive) {
                avt.classList.add('active');
            } else {
                avt.classList.remove('active');
            }

            // æ‰‹ç‰Œæ˜¾ç¤º
            const zone = $(`hand-${i}`);
            if (! zone) return;
            
            if (zone.children.length === 3 && p.hand && p.hand.length === 3) {
                const shouldShow = (i === myPid && p.seen) || (p.seen && ! state.roundActive);
                Array.from(zone.children).forEach((w, idx) => {
                    if (shouldShow && ! p.folded) {
                        const c = p.hand[idx];
                        const frontEl = w.querySelector('.card-front');
                        const backEl = w.querySelector('.card-back');
                        
                        if (frontEl && backEl && c) {
                            backEl.style.transform = "rotateY(180deg)";
                            frontEl.style. transform = "rotateY(0deg)";
                            frontEl.className = `card-face card-front ${['â™¥', 'â™¦']. includes(c.s) ? 'red' : ''}`;
                            frontEl.innerText = c.s + c.r;
                        }
                    }
                });
            }
        });

        // æ§åˆ¶é¢æ¿
        const me = state.players[myPid];
        if (! me) return;
        
        const isTurn = (state.turn === myPid) && me.status === 'play' && state.roundActive;
        
        const tip = $('game-tip');
        if (me.folded) {
            tip.innerText = "å·²å¼ƒç‰Œï¼Œç­‰å¾…ä¸‹ä¸€å±€";
            tip.className = '';
        } else if (isTurn) {
            tip.innerText = me.seen ? "è½®åˆ°ä½ äº† (å·²çœ‹ç‰Œï¼Œä¸‹æ³¨ç¿»å€)" : "è½®åˆ°ä½ äº† (é—·ç‰Œä¸­)";
            tip.className = 'your-turn';
        } else {
            tip.innerText = `ç­‰å¾… P${state.turn + 1} è¡ŒåŠ¨... `;
            tip.className = '';
        }

        $('btn-fold').disabled = !isTurn;
        $('btn-look').disabled = !isTurn || me.seen;
        $('btn-comp').disabled = !isTurn;
        $('comp-price').innerText = me.seen ? "200" : "100";

        [5, 10, 20, 50, 100].forEach(val => {
            const btn = $(`chip-${val}`);
            const tag = $(`tag-${val}`);
            
            if (isTurn) {
                btn.classList.remove('disabled');
                const cost = me.seen ? val * 2 : val;
                tag.innerText = `-${cost}`;
                tag.style.background = me.seen ? '#c0392b' : 'rgba(0,0,0,0.8)';
                tag.style.color = me. seen ? '#fff' : '#f1c40f';
            } else {
                btn.classList.add('disabled');
                tag.innerText = val;
                tag.style.background = 'rgba(0,0,0,0.8)';
                tag.style.color = '#fff';
            }
        });
    }

    // ==================== åŠ¨ç”» ====================
    function playDealAnim(pid, cIdx) {
        const deckRect = $('deck-pile').getBoundingClientRect();
        const w = document.createElement('div');
        w.className = 'card-wrapper';
        w.innerHTML = `
            <div class="card-face card-front"></div>
            <div class="card-face card-back" style="transform: rotateY(0deg);"></div>
        `;
        $('anim-layer').appendChild(w);
        
        w.style.left = deckRect.left + 'px';
        w.style.top = deckRect.top + 'px';
        
        const zone = $(`hand-${pid}`);
        if (!zone) {
            w.remove();
            return;
        }
        
        const zoneRect = zone.getBoundingClientRect();
        const targetX = zoneRect.left + 15 + cIdx * 25;
        const targetY = zoneRect.top + 5;

        requestAnimationFrame(() => {
            w.style.left = targetX + 'px';
            w.style.top = targetY + 'px';
            w.style.transform = `rotate(${(cIdx - 1) * 5}deg)`;
        });

        setTimeout(() => {
            w.remove();
            
            const staticW = document.createElement('div');
            staticW.className = 'card-wrapper';
            staticW.style.position = 'absolute';
            staticW.style. left = (15 + cIdx * 25) + 'px';
            staticW.style.top = '5px';
            staticW.style.transform = `rotate(${(cIdx - 1) * 5}deg)`;
            staticW.innerHTML = `
                <div class="card-face card-front" style="transform: rotateY(180deg);"></div>
                <div class="card-face card-back" style="transform: rotateY(0deg);"></div>
            `;
            
            zone.appendChild(staticW);
        }, 600);
    }

    function playChipAnim(pid, val) {
        const c = document.createElement('div');
        c.className = `chip-btn c-${val}`;
        c.innerText = val;
        c. style.position = 'absolute';
        c.style.border = 'none';
        c.style.boxShadow = 'none';
        c.style.transition = 'none';
        $('anim-layer').appendChild(c);

        const seat = $(`seat-${pid}`);
        if (!seat) {
            c.remove();
            return;
        }
        
        const seatRect = seat.getBoundingClientRect();
        c.style.left = (seatRect.left + 50) + 'px';
        c.style.top = (seatRect.top + 50) + 'px';

        const potRect = $('pot-area').getBoundingClientRect();
        const rx = (Math.random() - 0.5) * 100;
        const ry = (Math.random() - 0.5) * 40;

        requestAnimationFrame(() => {
            c.style.transition = "all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
            c.style.left = (potRect.left + potRect.width / 2 + rx) + 'px';
            c.style.top = (potRect.top + potRect. height / 2 + ry) + 'px';
            c.style.transform = `scale(0.6) rotate(${Math.random() * 360}deg)`;
        });
        
        setTimeout(() => c.remove(), 600);
    }

    function copyId() {
        const input = $('my-id-disp');
        input.select();
        input.setSelectionRange(0, 99999);
        
        try {
            document.execCommand('copy');
            toast("IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
        } catch (err) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(input.value)
                    .then(() => toast("IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿"))
                    . catch(() => toast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶"));
            } else {
                toast("è¯·æ‰‹åŠ¨å¤åˆ¶ID");
            }
        }
    }

    // ==================== é¡µé¢ç”Ÿå‘½å‘¨æœŸ ====================
    document.addEventListener('visibilitychange', () => {
        if (! document.hidden && state.phase === 'game') {
            console.log('ğŸ”„ é¡µé¢é‡æ–°æ˜¾ç¤ºï¼Œåˆ·æ–°UI');
            renderUI();
        }
    });

    window.addEventListener('beforeunload', () => {
        if (heartbeatTimer) clearInterval(heartbeatTimer);
        if (peer && ! peer.destroyed) peer.destroy();
    });
</script>
</body>
</html>
